{-# LANGUAGE ScopedTypeVariables #-}
module Test.Compilation.Snarkjs where

import Keelung
import Test.Hspec
import System.Process
import System.Directory
import GHC.IO.Exception (ExitCode(..))
import Data.Either (isRight)
import Data.Functor ((<&>))
import qualified System.Info
import System.IO.Error (catchIOError)

run :: IO ()
run = hspec tests

tests :: SpecWith ()
tests = do
  let inDir = withCurrentDirectory "snarkjs"
  describe ("Testing Snarkjs-related compiler functions...\n[ INFO ] These tests are possible only if you have Keelung compiler >= " <> keelungVersion <> " and Snarkjs installed.") $ do
    _ <- runIO (createDirectoryIfMissing True "snarkjs")
    it "Generating .r1cs file (echo)" $ do
      shouldReturn (inDir (genCircuitBin "echo.r1cs" bn128 echo) <&> isRight) True
    it "Generating .r1cs file (quad)" $ do
      shouldReturn (inDir (genCircuitBin "quad.r1cs" bn128 quad) <&> isRight) True
    it "Generating .wtns file (echo)" $ do
      shouldReturn (inDir (genWtns "echo.wtns" bn128 echo [] [1]) <&> isRight) True
    it "Generating .wtns file (quad)" $ do
      shouldReturn (inDir (genWtns "quad.wtns" bn128 quad [3,5,-22] [2]) <&> isRight) True

  describe ("Testing Snarkjs-related compiler functions...\n[ INFO ] These tests are possible only if you have Keelung compiler >= " <> keelungVersion <> " and Snarkjs installed.") $ do
    snarkjsExists <- runIO (checkCmd "snarkjs")
    (code, _, _) <- if snarkjsExists then runIO (readProcessWithExitCode "snarkjs" [] [])
                                     else return (ExitFailure 127, "", "")
    if code == ExitFailure 99 then
      describe "Testing compatibility with Snarkjs" $ do
        it "Checking if Snarkjs exists" $ do
          shouldReturn (readProcessWithExitCode "snarkjs" [] [] <&> (\ (a,_,_) -> a)) (ExitFailure 99)
        it "Generating .ptau files with Snarkjs" $ do
          shouldReturn (setupSnarkjsPtau 10 "abcd" <&> isRight) True
        it "Generating .zkey with Snarkjs (echo)" $ do
          shouldReturn (genZkeyBySnarkjs PLONK "snarkjs/echo.r1cs" "snarkjs/pot10_final.ptau" <&> isRight) True
        it "Generating .zkey (quad)" $ do
          shouldReturn (genZkeyBySnarkjs PLONK "snarkjs/quad.r1cs" "snarkjs/pot10_final.ptau" <&> isRight) True
        it "Checking correctness of .wtns generated by Keelung with Snarkjs (echo)" $ do
          shouldReturn (checkWtnsBySnarkjs "snarkjs/echo.r1cs" "snarkjs/echo.wtns" <&> isRight) True
        it "Checking correctness of .wtns generated by Keelung with Snarkjs (quad)" $ do
          shouldReturn (checkWtnsBySnarkjs "snarkjs/quad.r1cs" "snarkjs/quad.wtns" <&> isRight) True
        it "Proving Keelung\'s .r1cs and .wtns by Snarkjs (echo)" $ do
          shouldReturn (proveBySnarkjs PLONK "snarkjs/echo.zkey" "snarkjs/echo.wtns" <&> isRight) True
        it "Proving Keelung\'s .r1cs and .wtns by Snarkjs (quad)" $ do
          shouldReturn (proveBySnarkjs PLONK "snarkjs/quad.zkey" "snarkjs/quad.wtns" <&> isRight) True
    else do
      _ <- runIO (putStrLn "snarkjs not found, related tests skipped.")
      return ()
-- GenCircuitBin

-- GenWtns

-- | A program that outputs whatever number is given.
echo :: Comp Field
echo = input Private -- request for a private input and return it

quad :: Comp ()
quad = do
    _a :: Field <- input Public
    _b :: Field <- input Public
    _c :: Field <- input Public
    _x :: Field <- input Private
    assert (eq (_a * _x * _x + _b * _x + _c) 0)
    return ()

-- | Check if a command exists
checkCmd :: String -> IO Bool
checkCmd cmd =
    catchIOError
      (readProcess whichCmd [cmd] mempty >> return True)
      (\_ -> return False)
  where
    -- decide the command for locating executables
    whichCmd :: String
    whichCmd = case System.Info.os of
      "mingw32" -> "where" -- Windows uses "where"
      _ -> "which" -- Unix uses "which"